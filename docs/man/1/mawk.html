<html lang="en-US">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>mawk (1)</title>
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="">
<link href="https://fonts.googleapis.com/css2?family=Fira+Mono:wght@400;500;700&amp;display=swap" rel="stylesheet">
<link href="/index.css" rel="stylesheet" />
</head>
<body style="overscroll-behavior-x: auto">
<main>
<table class="head">
  <tr>
    <td class="head-ltitle">MAWK(1)</td>
    <td class="head-vol">User commands</td>
    <td class="head-rtitle">MAWK(1)</td>
  </tr>
</table>
<div class="manual-text">
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
<p class="Pp">mawk - pattern scanning and text processing language</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SYNOPSIS"><a class="permalink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<p class="Pp"><b>mawk</b> [-<b>W</b> <i>option</i>] [-<b>F</b> <i>value</i>]
    [-<b>v</b> <i>var=value</i>] [--] 'program text' [file ...]
  <br/>
  <b>mawk</b> [-<b>W</b> <i>option</i>] [-<b>F</b> <i>value</i>] [-<b>v</b>
    <i>var=value</i>] [-<b>f</b> <i>program-file</i>] [--] [file ...]</p>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
<p class="Pp"><b>mawk</b> is an interpreter for the AWK Programming Language.
    The AWK language is useful for manipulation of data files, text retrieval
    and processing, and for prototyping and experimenting with algorithms.
    <b>mawk</b> is a <i>new awk</i> meaning it implements the AWK language as
    defined in Aho, Kernighan and Weinberger, <i>The AWK Programming
    Language,</i> Addison-Wesley Publishing, 1988 (hereafter referred to as the
    AWK book.) <b>mawk</b> conforms to the POSIX 1003.2 (draft 11.3) definition
    of the AWK language which contains a few features not described in the AWK
    book, and <b>mawk</b> provides a small number of extensions.</p>
<p class="Pp">An AWK program is a sequence of <i>pattern {action}</i> pairs and
    function definitions. Short programs are entered on the command line usually
    enclosed in ' ' to avoid shell interpretation. Longer programs can be read
    in from a file with the -f option. Data input is read from the list of files
    on the command line or from standard input when the list is empty. The input
    is broken into records as determined by the record separator variable,
    <b>RS</b>. Initially, <b>RS</b> = &#x201C;\n&#x201D; and records are
    synonymous with lines. Each record is compared against each <i>pattern</i>
    and if it matches, the program text for <i>{action}</i> is executed.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="OPTIONS"><a class="permalink" href="#OPTIONS">OPTIONS</a></h1>
<dl class="Bl-tag">
  <dt id="F"><a class="permalink" href="#F">-<b>F
    </b><i>value</i><b></b></a></dt>
  <dd>sets the field separator, <b>FS</b>, to <i>value</i>.</dd>
  <dt id="f"><a class="permalink" href="#f">-<b>f </b><i>file</i></a></dt>
  <dd>Program text is read from <i>file</i> instead of from the command line.
      Multiple <b>-f</b> options are allowed.</dd>
  <dt id="v"><a class="permalink" href="#v">-<b>v </b><i>var=value</i></a></dt>
  <dd>assigns <i>value</i> to program variable <i>var</i>.</dd>
  <dt>--</dt>
  <dd>indicates the unambiguous end of options.</dd>
</dl>
<p class="Pp">The above options will be available with any POSIX compatible
    implementation of AWK. Implementation specific options are prefaced with
    <b>-W</b>. <b>mawk</b> provides these:</p>
<dl class="Bl-tag">
  <dt id="W"><a class="permalink" href="#W">-<b>W </b>dump</a></dt>
  <dd>writes an assembler like listing of the internal representation of the
      program to stdout and exits 0 (on successful compilation).</dd>
  <dt id="W~2"><a class="permalink" href="#W~2">-<b>W </b>exec
    <i>file</i></a></dt>
  <dd>Program text is read from <i>file</i> and this is the last option.</dd>
</dl>
<dl class="Bl-tag">
  <dt></dt>
  <dd>This is a useful alternative to -<b>f</b> on systems that support the
      <b>#!</b> &#x201C;magic number&#x201D; convention for executable scripts.
      Those implicitly pass the pathname of the script itself as the final
      parameter, and expect no more than one &#x201C;-&#x201D; option on the
      <b>#!</b> line. Because <b>mawk</b> can combine multiple -<b>W</b> options
      separated by commas, you can use this option when an additional -<b>W</b>
      option is needed.</dd>
</dl>
<dl class="Bl-tag">
  <dt id="W~3"><a class="permalink" href="#W~3">-<b>W </b>help</a></dt>
  <dd>prints a usage message to stderr and exits (same as
      &#x201C;-<b>W&#x00A0;</b>usage&#x201D;).</dd>
  <dt id="W~4"><a class="permalink" href="#W~4">-<b>W </b>interactive</a></dt>
  <dd>sets unbuffered writes to stdout and line buffered reads from stdin.
      Records from stdin are lines regardless of the value of <b>RS</b>.</dd>
  <dt id="W~5"><a class="permalink" href="#W~5">-<b>W </b>posix</a></dt>
  <dd>modifies <b>mawk</b>'s behavior to be more POSIX-compliant:</dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt>&#x2022;</dt>
  <dd>forces <b>mawk</b> not to consider '\n' to be space.</dd>
</dl>
</div>
<dl class="Bl-tag">
  <dt></dt>
  <dd>The original &#x201C;posix_space&#x201D; is recognized, but
    deprecated.</dd>
</dl>
<dl class="Bl-tag">
  <dt id="W~6"><a class="permalink" href="#W~6">-<b>W
    </b>random=<i>num</i></a></dt>
  <dd>calls <b>srand</b> with the given parameter (and overrides the
      auto-seeding behavior).</dd>
  <dt id="W~7"><a class="permalink" href="#W~7">-<b>W
    </b>sprintf=<i>num</i></a></dt>
  <dd>adjusts the size of <b>mawk</b>'s internal sprintf buffer to <i>num</i>
      bytes. More than rare use of this option indicates <b>mawk</b> should be
      recompiled.</dd>
  <dt id="W~8"><a class="permalink" href="#W~8">-<b>W </b>traditional</a></dt>
  <dd>Omit features such as interval expressions which were not supported by
      traditional <i>awk</i>.</dd>
  <dt id="W~9"><a class="permalink" href="#W~9">-<b>W </b>usage</a></dt>
  <dd>prints a usage message to stderr and exits (same as
      &#x201C;-<b>W&#x00A0;</b>help&#x201D;).</dd>
  <dt id="W~10"><a class="permalink" href="#W~10">-<b>W </b>version</a></dt>
  <dd><b>mawk</b> writes its version and copyright to stdout and compiled limits
      to stderr and exits 0.</dd>
</dl>
<p class="Pp"><b>mawk</b> accepts abbreviations for any of these options, e.g.,
    &#x201C;-<b>W&#x00A0;</b>v&#x201D; and &#x201C;-<b>W</b>v&#x201D; both tell
    <b>mawk</b> to show its version.</p>
<p class="Pp"><b>mawk</b> allows multiple <b>-W</b> options to be combined by
    separating the options with commas, e.g., -Wsprint=2000,posix. This is
    useful for executable <b>#!</b> &#x201C;magic number&#x201D; invocations in
    which only one argument is supported, e.g., -<b>Winteractive,exec</b>.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="THE_AWK_LANGUAGE"><a class="permalink" href="#THE_AWK_LANGUAGE">THE
  AWK LANGUAGE</a></h1>
<section class="Ss">
<h2 class="Ss"><b>1. Program structure</b></h2>
<p class="Pp">An AWK program is a sequence of <i>pattern {action}</i> pairs and
    user function definitions.</p>
<p class="Pp">A pattern can be:</p>
<div class="Bd-indent">
<pre><b>BEGIN</b>
<b>END</b>
expression
expression , expression

</pre>
</div>
<pre></pre>
One, but not both, of <i>pattern {action}</i> can be omitted. If <i>{action}</i>
  is omitted it is implicitly { print }. If <i>pattern</i> is omitted, then it
  is implicitly matched. <b>BEGIN</b> and <b>END</b> patterns require an action.
<p class="Pp">Statements are terminated by newlines, semi-colons or both. Groups
    of statements such as actions or loop bodies are blocked via
    {&#x00A0;...&#x00A0;} as in C. The last statement in a block doesn't need a
    terminator. Blank lines have no meaning; an empty statement is terminated
    with a semi-colon. Long statements can be continued with a backslash, \. A
    statement can be broken without a backslash after a comma, left brace,
    &amp;&amp;, ||, <b>do</b>, <b>else</b>, the right parenthesis of an
    <b>if</b>, <b>while</b> or <b>for</b> statement, and the right parenthesis
    of a function definition. A comment starts with # and extends to, but does
    not include the end of line.</p>
<p class="Pp">The following statements control program flow inside blocks.</p>
<div class="Bd-indent">
<p class="Pp"><b>if</b> ( <i>expr</i> ) <i>statement</i></p>
<p class="Pp"><b>if</b> ( <i>expr</i> ) <i>statement</i> <b>else</b>
    <i>statement</i></p>
<p class="Pp"><b>while</b> ( <i>expr</i> ) <i>statement</i></p>
<p class="Pp"><b>do</b> <i>statement</i> <b>while</b> ( <i>expr</i> )</p>
<p class="Pp"><b>for</b> ( <i>opt_expr</i> ; <i>opt_expr</i> ; <i>opt_expr</i> )
    <i>statement</i></p>
<p class="Pp"><b>for</b> ( <i>var </i><b>in </b><i>array</i> )
  <i>statement</i></p>
<p class="Pp"><b>continue</b></p>
<p class="Pp"><b>break</b></p>
</div>
</section>
<section class="Ss">
<h2 class="Ss"><b>2. Data types, conversion and comparison</b></h2>
<p class="Pp">There are two basic data types, numeric and string. Numeric
    constants can be integer like -2, decimal like 1.08, or in scientific
    notation like -1.1e4 or .28E-3. All numbers are represented internally and
    all computations are done in floating point arithmetic. So for example, the
    expression 0.2e2 == 20 is true and true is represented as 1.0.</p>
<p class="Pp">String constants are enclosed in double quotes.</p>
<p class="Pp">
  <br/>
  &quot;This is a string with a newline at the end.\n&quot;</p>
<p class="Pp">
  <br/>
  Strings can be continued across a line by escaping (\) the newline. The
    following escape sequences are recognized.</p>
<pre>
	\\		\
	\&quot;		&quot;
	\a		alert, ascii 7
	\b		backspace, ascii 8
	\t		tab, ascii 9
	\n		newline, ascii 10
	\v		vertical tab, ascii 11
	\f		formfeed, ascii 12
	\r		carriage return, ascii 13
	\ddd		1, 2 or 3 octal digits for ascii ddd
	\xhh		1 or 2 hex digits for ascii  hh

</pre>
If you escape any other character \c, you get \c, i.e., <b>mawk</b> ignores the
  escape.
<p class="Pp">There are really three basic data types; the third is <i>number
    and string</i> which has both a numeric value and a string value at the same
    time. User defined variables come into existence when first referenced and
    are initialized to <i>null</i>, a number and string value which has numeric
    value 0 and string value &quot;&quot;. Non-trivial number and string typed
    data come from input and are typically stored in fields. (See section
  4).</p>
<p class="Pp">The type of an expression is determined by its context and
    automatic type conversion occurs if needed. For example, to evaluate the
    statements</p>
<pre>
	y = x + 2  ;  z = x  &quot;hello&quot;

</pre>
The value stored in variable y will be typed numeric. If x is not numeric, the
  value read from x is converted to numeric before it is added to 2 and stored
  in y. The value stored in variable z will be typed string, and the value of x
  will be converted to string if necessary and concatenated with
  &quot;hello&quot;. (Of course, the value and type stored in x is not changed
  by any conversions.) A string expression is converted to numeric using its
  longest numeric prefix as with <b>atof</b>(3). A numeric expression is
  converted to string by replacing <i>expr</i> with <b>sprintf(CONVFMT</b>,
  <i>expr</i>), unless <i>expr</i> can be represented on the host machine as an
  exact integer then it is converted to <b>sprintf</b>(&quot;%d&quot;,
  <i>expr</i>). <b>Sprintf()</b> is an AWK built-in that duplicates the
  functionality of <b>sprintf</b>(3), and <b>CONVFMT</b> is a built-in variable
  used for internal conversion from number to string and initialized to
  &quot;%.6g&quot;. Explicit type conversions can be forced, <i>expr</i>
  &quot;&quot; is string and <i>expr</i>+0 is numeric.
<p class="Pp">To evaluate, <i>expr</i>1 <b>rel-op</b> <i>expr</i>2, if both
    operands are numeric or number and string then the comparison is numeric; if
    both operands are string the comparison is string; if one operand is string,
    the non-string operand is converted and the comparison is string. The result
    is numeric, 1 or 0.</p>
<p class="Pp">In boolean contexts such as, <b>if</b> ( <i>expr</i> )
    <i>statement</i>, a string expression evaluates true if and only if it is
    not the empty string &quot;&quot;; numeric values if and only if not
    numerically zero.</p>
</section>
<section class="Ss">
<h2 class="Ss"><b>3. Regular expressions</b></h2>
<p class="Pp">In the AWK language, records, fields and strings are often tested
    for matching a <i>regular expression</i>. Regular expressions are enclosed
    in slashes, and</p>
<pre>
	<i>expr</i> ~ /<i>r</i>/

</pre>
<p class="Pp">is an AWK expression that evaluates to 1 if <i>expr</i>
    &#x201C;matches&#x201D; <i>r</i>, which means a substring of <i>expr</i> is
    in the set of strings defined by <i>r</i>. With no match the expression
    evaluates to 0; replacing ~ with the &#x201C;not match&#x201D; operator, !~
    , reverses the meaning. As pattern-action pairs,</p>
<pre>
	/<i>r</i>/ { <i>action</i> }   and   <b>$0</b> ~ /<i>r</i>/ { <i>action</i> }

</pre>
<p class="Pp">are the same, and for each input record that matches <i>r</i>,
    <i>action</i> is executed. In fact, /<i>r</i>/ is an AWK expression that is
    equivalent to (<b>$0</b> ~ /<i>r</i>/) anywhere except when on the right
    side of a match operator or passed as an argument to a built-in function
    that expects a regular expression argument.</p>
<p class="Pp">AWK uses extended regular expressions as with the <b>-E</b> option
    of <b>grep</b>(1). The regular expression metacharacters, i.e., those with
    special meaning in regular expressions are</p>
<pre>
	\ ^ $ . [ ] | ( ) * + ? { }

</pre>
If the command line option <i>-W traditional</i> is used, these are omitted:
<pre>
	{ }

</pre>
are also regular expression metacharacters, and in this mode, require escaping
  to be a literal character.
<p class="Pp">Regular expressions are built up from characters as follows:</p>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="c"><a class="permalink" href="#c"><i>c</i></a></dt>
  <dd>matches any non-metacharacter <i>c</i>.</dd>
  <dt id="c~2"><a class="permalink" href="#c~2">\<i>c</i></a></dt>
  <dd>matches a character defined by the same escape sequences used in string
      constants or the literal character <i>c</i> if \<i>c</i> is not an escape
      sequence.</dd>
  <dt>.</dt>
  <dd>matches any character (including newline).</dd>
  <dt>^</dt>
  <dd>matches the front of a string.</dd>
  <dt>$</dt>
  <dd>matches the back of a string.</dd>
  <dt>[c1c2c3...]</dt>
  <dd>matches any character in the class c1c2c3...&#x00A0;. An interval of
      characters is denoted c1-c2 inside a class [...].</dd>
  <dt>[^c1c2c3...]</dt>
  <dd>matches any character not in the class c1c2c3...</dd>
</dl>
</div>
<p class="Pp">Regular expressions are built up from other regular expressions as
    follows:</p>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="r"><a class="permalink" href="#r"><i>r</i>1<i>r</i>2</a></dt>
  <dd>matches <i>r</i>1 followed immediately by <i>r</i>2
      (<i>concatenation</i>).
    <p class="Pp"></p>
  </dd>
  <dt id="r~2"><a class="permalink" href="#r~2"><i>r</i>1 | <i>r</i>2</a></dt>
  <dd>matches <i>r</i>1 or <i>r</i>2 (<i>alternation</i>).
    <p class="Pp"></p>
  </dd>
  <dt id="r~3"><a class="permalink" href="#r~3"><i>r</i>*</a></dt>
  <dd>matches <i>r</i> repeated zero or more times.</dd>
  <dt id="r~4"><a class="permalink" href="#r~4"><i>r</i>+</a></dt>
  <dd>matches <i>r</i> repeated one or more times.</dd>
  <dt id="r~5"><a class="permalink" href="#r~5"><i>r</i>?</a></dt>
  <dd>matches <i>r</i> zero or once. (<i>repetition</i>).</dd>
  <dt>(<i>r</i>)</dt>
  <dd>matches <i>r</i> (<i>grouping</i>).
    <p class="Pp"></p>
  </dd>
  <dt id="r~6"><a class="permalink" href="#r~6"><i>r</i>{n}</a></dt>
  <dd>matches <i>r</i> exactly n times.</dd>
  <dt id="r~7"><a class="permalink" href="#r~7"><i>r</i>{n,}</a></dt>
  <dd>matches <i>r</i> repeated n or more times.</dd>
  <dt id="r~8"><a class="permalink" href="#r~8"><i>r</i>{n,m}</a></dt>
  <dd>matches <i>r</i> repeated n to m (inclusive) times.</dd>
  <dt id="r~9"><a class="permalink" href="#r~9"><i>r</i>{,m}</a></dt>
  <dd>matches <i>r</i> repeated 0 to m times (a non-standard option).</dd>
</dl>
</div>
<p class="Pp">The increasing <b>precedence of operators</b> is:</p>
<pre>
alternation concatenation repetition grouping

</pre>
<p class="Pp">For example,</p>
<pre>
	/^[_a-zA-Z][_a-zA-Z0-9]*$/  and
	/^[-+]?([0-9]+\.?|\.[0-9])[0-9]*([eE][-+]?[0-9]+)?$/

</pre>
are matched by AWK identifiers and AWK numeric constants respectively. Note that
  &#x201C;.&#x201D; has to be escaped to be recognized as a decimal point, and
  that metacharacters are not special inside character classes.
<p class="Pp">Any expression can be used on the right hand side of the ~ or !~
    operators or passed to a built-in that expects a regular expression. If
    needed, it is converted to string, and then interpreted as a regular
    expression. For example,</p>
<pre>
	BEGIN { identifier = &quot;[_a-zA-Z][_a-zA-Z0-9]*&quot; }
	$0 ~ &quot;^&quot; identifier

</pre>
prints all lines that start with an AWK identifier.
<p class="Pp"><b>mawk</b> recognizes the empty regular expression, //, which
    matches the empty string and hence is matched by any string at the front,
    back and between every character. For example,</p>
<pre>
	echo  abc | mawk '{ gsub(//, &quot;X&quot;)' ; print }
	XaXbXcX

</pre>
</section>
<section class="Ss">
<h2 class="Ss"><b>4. Records and fields</b></h2>
<p class="Pp">Records are read in one at a time, and stored in the <i>field</i>
    variable <b>$0</b>. The record is split into <i>fields</i> which are stored
    in <b>$1</b>, <b>$2</b>, ..., <b>$NF</b>. The built-in variable <b>NF</b> is
    set to the number of fields, and <b>NR</b> and <b>FNR</b> are incremented by
    1. Fields above <b>$NF</b> are set to &quot;&quot;.</p>
<p class="Pp">Assignment to <b>$0</b> causes the fields and <b>NF</b> to be
    recomputed. Assignment to <b>NF</b> or to a field causes <b>$0</b> to be
    reconstructed by concatenating the <b>$i's</b> separated by <b>OFS</b>.
    Assignment to a field with index greater than <b>NF</b>, increases <b>NF</b>
    and causes <b>$0</b> to be reconstructed.</p>
<p class="Pp">Data input stored in fields is string, unless the entire field has
    numeric form and then the type is number and string. For example,</p>
<p class="Pp"></p>
<pre>	echo 24 24E |
	mawk '{ print($1&gt;100, $1&gt;&quot;100&quot;, $2&gt;100, $2&gt;&quot;100&quot;) }'
	0 1 1 1</pre>
<p class="Pp"><b>$0</b> and <b>$2</b> are string and <b>$1</b> is number and
    string. The first comparison is numeric, the second is string, the third is
    string (100 is converted to &quot;100&quot;), and the last is string.</p>
</section>
<section class="Ss">
<h2 class="Ss"><b>5. Expressions and operators</b></h2>
<p class="Pp">The expression syntax is similar to C. Primary expressions are
    numeric constants, string constants, variables, fields, arrays and function
    calls. The identifier for a variable, array or function can be a sequence of
    letters, digits and underscores, that does not start with a digit. Variables
    are not declared; they exist when first referenced and are initialized to
    <i>null</i>.</p>
<p class="Pp">New expressions are composed with the following operators in order
    of increasing precedence.</p>
<p class="Pp"></p>
<div class="Bd-indent">
<pre><i>assignment</i>		=  +=  -=  *=  /=  %=  ^=
<i>conditional</i>		?  :
<i>logical or</i>		||
<i>logical and</i>		&amp;&amp;
<i>array membership</i>	<b>in</b>
<b></b><i>matching</i>		~   !~
<i>relational</i>		&lt;  &gt;   &lt;=  &gt;=  ==  !=
<i>concatenation</i>		(no explicit operator)
<i>add ops</i>			+  -
<i>mul ops</i>			*  /  %
<i>unary</i>			+  -
<i>logical not</i>		!
<i>exponentiation</i>		^
<i>inc and dec</i>		++ -- (both post and pre)
<i>field</i>			$</pre>
</div>
<pre></pre>
Assignment, conditional and exponentiation associate right to left; the other
  operators associate left to right. Any expression can be parenthesized.
</section>
<section class="Ss">
<h2 class="Ss"><b>6. Arrays</b></h2>
<p class="Pp">Awk provides one-dimensional arrays. Array elements are expressed
    as <i>array</i>[<i>expr</i>]. <i>Expr</i> is internally converted to string
    type, so, for example, A[1] and A[&quot;1&quot;] are the same element and
    the actual index is &quot;1&quot;. Arrays indexed by strings are called
    associative arrays. Initially an array is empty; elements exist when first
    accessed. An expression, <i>expr</i><b> in</b><i> array</i> evaluates to 1
    if <i>array</i>[<i>expr</i>] exists, else to 0.</p>
<p class="Pp">There is a form of the <b>for</b> statement that loops over each
    index of an array.</p>
<pre>
	<b>for</b> ( <i>var</i><b> in </b><i>array </i>) <i>statement</i>

</pre>
sets <i>var</i> to each index of <i>array</i> and executes <i>statement</i>. The
  order that <i>var</i> transverses the indices of <i>array</i> is not defined.
<p class="Pp">The statement, <b>delete</b> <i>array</i>[<i>expr</i>], causes
    <i>array</i>[<i>expr</i>] not to exist. <b>mawk</b> supports the
    <b>delete</b> <i>array</i> feature, which deletes all elements of
    <i>array</i>.</p>
<p class="Pp">Multidimensional arrays are synthesized with concatenation using
    the built-in variable <b>SUBSEP</b>. <i>array</i>[<i>expr</i>1,<i>expr</i>2]
    is equivalent to <i>array</i>[<i>expr</i>1 <b>SUBSEP </b><i>expr</i>2].
    Testing for a multidimensional element uses a parenthesized index, such
  as</p>
<p class="Pp"></p>
<pre>	if ( (i, j) in A )  print A[i, j]</pre>
<p class="Pp"></p>
</section>
<section class="Ss">
<h2 class="Ss"><b>7. Builtin-variables</b></h2>
<p class="Pp">The following variables are built-in and initialized before
    program execution.</p>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="ARGC"><a class="permalink" href="#ARGC"><b>ARGC</b></a></dt>
  <dd>number of command line arguments.</dd>
  <dt id="ARGV"><a class="permalink" href="#ARGV"><b>ARGV</b></a></dt>
  <dd>array of command line arguments, 0..ARGC-1.</dd>
  <dt id="CONVFMT"><a class="permalink" href="#CONVFMT"><b>CONVFMT</b></a></dt>
  <dd>format for internal conversion of numbers to string, initially =
      &quot;%.6g&quot;.</dd>
  <dt id="ENVIRON"><a class="permalink" href="#ENVIRON"><b>ENVIRON</b></a></dt>
  <dd>array indexed by environment variables. An environment string,
      <i>var=value</i> is stored as <b>ENVIRON</b>[<i>var</i>] =
    <i>value</i>.</dd>
  <dt id="FILENAME"><a class="permalink" href="#FILENAME"><b>FILENAME</b></a></dt>
  <dd>name of the current input file.</dd>
  <dt id="FNR"><a class="permalink" href="#FNR"><b>FNR</b></a></dt>
  <dd>current record number in <b>FILENAME</b>.</dd>
  <dt id="FS"><a class="permalink" href="#FS"><b>FS</b></a></dt>
  <dd>splits records into fields as a regular expression.</dd>
  <dt id="NF"><a class="permalink" href="#NF"><b>NF</b></a></dt>
  <dd>number of fields in the current record.</dd>
  <dt id="NR"><a class="permalink" href="#NR"><b>NR</b></a></dt>
  <dd>current record number in the total input stream.</dd>
  <dt id="OFMT"><a class="permalink" href="#OFMT"><b>OFMT</b></a></dt>
  <dd>format for printing numbers; initially = &quot;%.6g&quot;.</dd>
  <dt id="OFS"><a class="permalink" href="#OFS"><b>OFS</b></a></dt>
  <dd>inserted between fields on output, initially = &quot; &quot;.</dd>
  <dt id="ORS"><a class="permalink" href="#ORS"><b>ORS</b></a></dt>
  <dd>terminates each record on output, initially = &quot;\n&quot;.</dd>
  <dt id="RLENGTH"><a class="permalink" href="#RLENGTH"><b>RLENGTH</b></a></dt>
  <dd>length set by the last call to the built-in function, <b>match()</b>.</dd>
  <dt id="RS"><a class="permalink" href="#RS"><b>RS</b></a></dt>
  <dd>input record separator, initially = &quot;\n&quot;.</dd>
  <dt id="RSTART"><a class="permalink" href="#RSTART"><b>RSTART</b></a></dt>
  <dd>index set by the last call to <b>match()</b>.</dd>
  <dt id="SUBSEP"><a class="permalink" href="#SUBSEP"><b>SUBSEP</b></a></dt>
  <dd>used to build multiple array subscripts, initially =
    &quot;\034&quot;.</dd>
</dl>
</div>
</section>
<section class="Ss">
<h2 class="Ss"><b>8. Built-in functions</b></h2>
<p class="Pp"><b>String functions</b></p>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="gsub("><a class="permalink" href="#gsub(">gsub(<i>r,s,t</i>)
    gsub(<i>r,s</i>)</a></dt>
  <dd>Global substitution, every match of regular expression <i>r</i> in
      variable <i>t</i> is replaced by string <i>s</i>. The number of
      replacements is returned. If <i>t</i> is omitted, <b>$0</b> is used. An
      <i>&amp;</i> in the replacement string <i>s</i> is replaced by the matched
      substring of <i>t</i>. \&amp; and \\ put literal &amp; and \,
      respectively, in the replacement string.</dd>
  <dt id="index("><a class="permalink" href="#index(">index(<i>s,t</i>)</a></dt>
  <dd>If <i>t</i> is a substring of <i>s</i>, then the position where <i>t</i>
      starts is returned, else 0 is returned. The first character of <i>s</i> is
      in position 1.</dd>
  <dt id="length("><a class="permalink" href="#length(">length(<i>s</i>)</a></dt>
  <dd>Returns the length of string or array <i>s</i>.</dd>
  <dt id="match("><a class="permalink" href="#match(">match(<i>s,r</i>)</a></dt>
  <dd>Returns the index of the first longest match of regular expression
      <i>r</i> in string <i>s</i>. Returns 0 if no match. As a side effect,
      <b>RSTART</b> is set to the return value. <b>RLENGTH</b> is set to the
      length of the match or -1 if no match. If the empty string is matched,
      <b>RLENGTH</b> is set to 0, and 1 is returned if the match is at the
      front, and length(<i>s</i>)+1 is returned if the match is at the
    back.</dd>
  <dt id="split("><a class="permalink" href="#split(">split(<i>s,A,r</i>)
    split(<i>s,A</i>)</a></dt>
  <dd>String <i>s</i> is split into fields by regular expression <i>r</i> and
      the fields are loaded into array <i>A</i>. The number of fields is
      returned. See section 11 below for more detail. If <i>r</i> is omitted,
      <b>FS</b> is used.</dd>
  <dt id="sprintf("><a class="permalink" href="#sprintf(">sprintf(<i>format,expr-list</i>)</a></dt>
  <dd>Returns a string constructed from <i>expr-list</i> according to
      <i>format</i>. See the description of printf() below.</dd>
  <dt id="sub("><a class="permalink" href="#sub(">sub(<i>r,s,t</i>)
    sub(<i>r,s</i>)</a></dt>
  <dd>Single substitution, same as gsub() except at most one substitution.</dd>
  <dt id="substr("><a class="permalink" href="#substr(">substr(<i>s,i,n</i>)
    substr(<i>s,i</i>)</a></dt>
  <dd>Returns the substring of string <i>s</i>, starting at index <i>i</i>, of
      length <i>n</i>. If <i>n</i> is omitted, the suffix of <i>s</i>, starting
      at <i>i</i> is returned.</dd>
  <dt id="tolower("><a class="permalink" href="#tolower(">tolower(<i>s</i>)</a></dt>
  <dd>Returns a copy of <i>s</i> with all upper case characters converted to
      lower case.</dd>
  <dt id="toupper("><a class="permalink" href="#toupper(">toupper(<i>s</i>)</a></dt>
  <dd>Returns a copy of <i>s</i> with all lower case characters converted to
      upper case.</dd>
</dl>
</div>
<p class="Pp"><b>Time functions</b></p>
<p class="Pp">These are available on systems which support the corresponding C
    <b>mktime</b> and <b>strftime</b> functions:</p>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="mktime("><a class="permalink" href="#mktime(">mktime(<i>specification</i>)</a></dt>
  <dd>converts a date specification to a timestamp with the same units as
      <b>systime</b>. The date specification is a string containing the
      components of the date as decimal integers:</dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="YYYY"><a class="permalink" href="#YYYY"><b>YYYY</b></a></dt>
  <dd>the year, e.g., 2012</dd>
  <dt id="MM"><a class="permalink" href="#MM"><b>MM</b></a></dt>
  <dd>the month of the year starting at 1</dd>
  <dt id="DD"><a class="permalink" href="#DD"><b>DD</b></a></dt>
  <dd>the day of the month starting at 1</dd>
  <dt id="HH"><a class="permalink" href="#HH"><b>HH</b></a></dt>
  <dd>hour (0-23)</dd>
  <dt id="MM~2"><a class="permalink" href="#MM~2"><b>MM</b></a></dt>
  <dd>minute (0-59)</dd>
  <dt id="SS"><a class="permalink" href="#SS"><b>SS</b></a></dt>
  <dd>seconds (0-59)</dd>
  <dt id="DST"><a class="permalink" href="#DST"><b>DST</b></a></dt>
  <dd>tells how to treat timezone versus daylight savings time:</dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="positive"><a class="permalink" href="#positive">positive</a></dt>
  <dd>DST is in effect</dd>
  <dt id="zero"><a class="permalink" href="#zero">zero (default)</a></dt>
  <dd>DST is not in effect</dd>
  <dt id="negative"><a class="permalink" href="#negative">negative</a></dt>
  <dd>mktime() should (use timezone information and system databases to) attempt
      to determine whether DST is in effect at the specified time.</dd>
</dl>
</div>
</div>
<dl class="Bl-tag">
  <dt id="strftime(_"><a class="permalink" href="#strftime(_">strftime([<i>format</i>
    [, <i>timestamp</i> [, <i>utc</i> ]]])</a></dt>
  <dd>formats the given timestamp using the format (passed to the C
      <b>strftime</b> function):</dd>
</dl>
<div class="Bd-indent">
<ul class="Bl-bullet">
  <li>If the <i>format</i> parameter is missing, &quot;%c&quot; is used.</li>
  <li>If the <i>timestamp</i> parameter is missing, the current value from
      <b>systime</b> is used.</li>
  <li>If the <i>utc</i> parameter is present and nonzero, the result is in UTC.
      Otherwise local time is used.</li>
</ul>
</div>
<dl class="Bl-tag">
  <dt id="systime()"><a class="permalink" href="#systime()">systime()</a></dt>
  <dd>returns the current time of day as the number of seconds since the Epoch
      (1970-01-01 00:00:00 UTC on POSIX systems).</dd>
</dl>
</div>
<p class="Pp"><b>Arithmetic functions</b></p>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="atan2("><a class="permalink" href="#atan2(">atan2(<i>y,x</i>)</a></dt>
  <dd>Arctan of <i>y</i>/<i>x</i> between -pi and pi.</dd>
  <dt id="cos("><a class="permalink" href="#cos(">cos(<i>x</i>)</a></dt>
  <dd>Cosine function, <i>x</i> in radians.</dd>
  <dt id="exp("><a class="permalink" href="#exp(">exp(<i>x</i>)</a></dt>
  <dd>Exponential function.</dd>
  <dt id="int("><a class="permalink" href="#int(">int(<i>x</i>)</a></dt>
  <dd>Returns <i>x</i> truncated towards zero.</dd>
  <dt id="log("><a class="permalink" href="#log(">log(<i>x</i>)</a></dt>
  <dd>Natural logarithm.</dd>
  <dt id="rand()"><a class="permalink" href="#rand()">rand()</a></dt>
  <dd>Returns a random number between zero and one.</dd>
  <dt id="sin("><a class="permalink" href="#sin(">sin(<i>x</i>)</a></dt>
  <dd>Sine function, <i>x</i> in radians.</dd>
  <dt id="sqrt("><a class="permalink" href="#sqrt(">sqrt(<i>x</i>)</a></dt>
  <dd>Returns square root of <i>x</i>.</dd>
  <dt id="srand("><a class="permalink" href="#srand(">srand(<i>expr</i>)</a></dt>
  <dd></dd>
  <dt id="srand()"><a class="permalink" href="#srand()">srand()</a></dt>
  <dd>Seeds the random number generator, using the clock if <i>expr</i> is
      omitted, and returns the value of the previous seed. Srand(<i>expr</i>) is
      useful for repeating pseudo random sequences.</dd>
</dl>
<dl class="Bl-tag">
  <dt></dt>
  <dd>Note: <b>mawk</b> is normally configured to seed the random number
      generator from the clock at startup, making it unnecessary to call
      srand(). This feature can be suppressed via conditional compile, or
      overridden using the <b>-Wrandom</b> option.</dd>
</dl>
</div>
</section>
<section class="Ss">
<h2 class="Ss"><b>9. Input and output</b></h2>
<p class="Pp">There are two output statements, <b>print</b> and
  <b>printf</b>.</p>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="print"><a class="permalink" href="#print">print</a></dt>
  <dd>writes <b>$0 ORS</b> to standard output.</dd>
  <dt>print <i>expr</i>1, <i>expr</i>2, ..., <i>expr</i>n</dt>
  <dd>writes <i>expr</i>1 <b>OFS </b><i>expr</i>2 <b>OFS</b> ... <i>expr</i>n
      <b>ORS</b> to standard output. Numeric expressions are converted to string
      with <b>OFMT</b>.</dd>
  <dt id="printf"><a class="permalink" href="#printf">printf <i>format,
    expr-list</i></a></dt>
  <dd>duplicates the printf C library function writing to standard output. The
      complete ANSI C format specifications are recognized with conversions %c,
      %d, %e, %E, %f, %g, %G, %i, %o, %s, %u, %x, %X and %%, and conversion
      qualifiers h and l.</dd>
</dl>
</div>
<p class="Pp">The argument list to print or printf can optionally be enclosed in
    parentheses. Print formats numbers using <b>OFMT</b> or &quot;%d&quot; for
    exact integers. &quot;%c&quot; with a numeric argument prints the
    corresponding 8 bit character, with a string argument it prints the first
    character of the string. The output of print and printf can be redirected to
    a file or command by appending &gt; <i>file</i>, &gt;&gt; <i>file</i> or |
    <i>command</i> to the end of the print statement. Redirection opens
    <i>file</i> or <i>command</i> only once, subsequent redirections append to
    the already open stream. By convention, <b>mawk</b> associates the
  filename</p>
<div class="Bd-indent">
<ul class="Bl-bullet">
  <li>&quot;/dev/stderr&quot; with stderr,</li>
  <li>&quot;/dev/stdout&quot; with stdout,</li>
  <li>&quot;-&quot; and &quot;/dev/stdin&quot; with stdin.</li>
</ul>
</div>
<p class="Pp">The association with stderr is especially useful because it allows
    print and printf to be redirected to stderr. These names can also be passed
    to functions.</p>
<p class="Pp">The input function <b>getline</b> has the following
  variations.</p>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="getline"><a class="permalink" href="#getline">getline</a></dt>
  <dd>reads into <b>$0</b>, updates the fields, <b>NF</b>, <b>NR</b> and
      <b>FNR</b>.</dd>
  <dt>getline &lt; <i>file</i></dt>
  <dd>reads into <b>$0</b> from <i>file</i>, updates the fields and
    <b>NF</b>.</dd>
  <dt>getline <i>var</i></dt>
  <dd>reads the next record into <i>var</i>, updates <b>NR</b> and
    <b>FNR</b>.</dd>
  <dt>getline <i>var</i> &lt; <i>file</i></dt>
  <dd>reads the next record of <i>file</i> into <i>var</i>.</dd>
  <dt id="command"><a class="permalink" href="#command"><i>command</i> |
    getline</a></dt>
  <dd>pipes a record from <i>command</i> into <b>$0</b> and updates the fields
      and <b>NF</b>.</dd>
  <dt id="command~2"><a class="permalink" href="#command~2"><i>command</i> |
    getline <i>var</i></a></dt>
  <dd>pipes a record from <i>command</i> into <i>var</i>.</dd>
</dl>
</div>
<p class="Pp">Getline returns 0 on end-of-file, -1 on error, otherwise 1.</p>
<p class="Pp">Commands on the end of pipes are executed by /bin/sh.</p>
<p class="Pp">The function <b>close</b>(<i>expr</i>) closes the file or pipe
    associated with <i>expr</i>. Close returns 0 if <i>expr</i> is an open file,
    the exit status if <i>expr</i> is a piped command, and -1 otherwise. Close
    is used to reread a file or command, make sure the other end of an output
    pipe is finished or conserve file resources.</p>
<p class="Pp">The function <b>fflush</b>(<i>expr</i>) flushes the output file or
    pipe associated with <i>expr</i>. Fflush returns 0 if <i>expr</i> is an open
    output stream else -1. Fflush without an argument flushes stdout. Fflush
    with an empty argument (&quot;&quot;) flushes all open output.</p>
<p class="Pp">The function <b>system</b>(<i>expr</i>) uses the C runtime
    <b>system</b> call to execute <i>expr</i> and returns the corresponding wait
    status of the command as follows:</p>
<ul class="Bl-bullet">
  <li>if the <b>system</b> call failed, setting the status to -1, <b>mawk</b>
      returns that value.</li>
  <li>if the command exited normally, <b>mawk</b> returns its exit-status.</li>
  <li>if the command exited due to a signal such as <b>SIGHUP</b>, <b>mawk</b>
      returns the signal number plus 256.</li>
</ul>
<p class="Pp">Changes made to the <b>ENVIRON</b> array are not passed to
    commands executed with <b>system</b> or pipes.</p>
</section>
<section class="Ss">
<h2 class="Ss"><b>10. User defined functions</b></h2>
<p class="Pp">The syntax for a user defined function is</p>
<pre>
	<b>function</b> name( <i>args</i> ) { <i>statements</i> }

</pre>
<p class="Pp">The function body can contain a return statement</p>
<pre>
	<b>return</b><i> opt_expr</i>

</pre>
<p class="Pp">A return statement is not required. Function calls may be nested
    or recursive. Functions are passed expressions by value and arrays by
    reference. Extra arguments serve as local variables and are initialized to
    <i>null</i>. For example, csplit(<i>s,A</i>) puts each character of <i>s</i>
    into array <i>A</i> and returns the length of <i>s</i>.</p>
<pre>
	function csplit(s, A,	n, i)
	{
	  n = length(s)
	  for( i = 1 ; i &lt;= n ; i++ ) A[i] = substr(s, i, 1)
	  return n
	}

</pre>
<p class="Pp">Putting extra space between passed arguments and local variables
    is conventional. Functions can be referenced before they are defined, but
    the function name and the '(' of the arguments must touch to avoid confusion
    with concatenation.</p>
<p class="Pp">A function parameter is normally a scalar value (number or
    string). If there is a forward reference to a function using an array as a
    parameter, the function's corresponding parameter will be treated as an
    array.</p>
</section>
<section class="Ss">
<h2 class="Ss"><b>11. Splitting strings, records and files</b></h2>
<p class="Pp">Awk programs use the same algorithm to split strings into arrays
    with split(), and records into fields on <b>FS</b>. <b>mawk</b> uses
    essentially the same algorithm to split files into records on <b>RS</b>.</p>
<p class="Pp">Split(<i>expr,A,sep</i>) works as follows:</p>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt>(1)</dt>
  <dd>If <i>sep</i> is omitted, it is replaced by <b>FS</b>. <i>Sep</i> can be
      an expression or regular expression. If it is an expression of non-string
      type, it is converted to string.</dd>
  <dt>(2)</dt>
  <dd>If <i>sep</i> = &quot; &quot; (a single space), then &lt;SPACE&gt; is
      trimmed from the front and back of <i>expr</i>, and <i>sep</i> becomes
      &lt;SPACE&gt;. <b>mawk</b> defines &lt;SPACE&gt; as the regular expression
      /[&#x00A0;\t\n]+/. Otherwise <i>sep</i> is treated as a regular
      expression, except that meta-characters are ignored for a string of length
      1, e.g., split(x, A, &quot;*&quot;) and split(x, A, /\*/) are the
    same.</dd>
  <dt>(3)</dt>
  <dd>If <i>expr</i> is not string, it is converted to string. If <i>expr</i> is
      then the empty string &quot;&quot;, split() returns 0 and <i>A</i> is set
      empty. Otherwise, all non-overlapping, non-null and longest matches of
      <i>sep</i> in <i>expr</i>, separate <i>expr</i> into fields which are
      loaded into <i>A</i>. The fields are placed in A[1], A[2], ..., A[n] and
      split() returns n, the number of fields which is the number of matches
      plus one. Data placed in <i>A</i> that looks numeric is typed number and
      string.</dd>
</dl>
</div>
<p class="Pp">Splitting records into fields works the same except the pieces are
    loaded into <b>$1</b>, <b>$2</b>,..., <b>$NF</b>. If <b>$0</b> is empty,
    <b>NF</b> is set to 0 and all <b>$i</b> to &quot;&quot;.</p>
<p class="Pp"><b>mawk</b> splits files into records by the same algorithm, but
    with the slight difference that <b>RS</b> is really a terminator instead of
    a separator. (<b>ORS</b> is really a terminator too).</p>
<div class="Bd-indent">
<p class="Pp">E.g., if <b>FS</b> = &#x201C;:+&#x201D; and <b>$0</b> =
    &#x201C;a::b:&#x201D; , then <b>NF</b> = 3 and <b>$1</b> =
    &#x201C;a&#x201D;, <b>$2</b> = &#x201C;b&#x201D; and <b>$3</b> =
    &quot;&quot;, but if &#x201C;a::b:&#x201D; is the contents of an input file
    and <b>RS</b> = &#x201C;:+&#x201D;, then there are two records
    &#x201C;a&#x201D; and &#x201C;b&#x201D;.</p>
</div>
<p class="Pp"><b>RS</b> = &quot; &quot; is not special.</p>
<p class="Pp">If <b>FS</b> = &quot;&quot;, then <b>mawk</b> breaks the record
    into individual characters, and, similarly, split(<i>s,A,</i>&quot;&quot;)
    places the individual characters of <i>s</i> into <i>A</i>.</p>
</section>
<section class="Ss">
<h2 class="Ss"><b>12. Multi-line records</b></h2>
<p class="Pp">Since <b>mawk</b> interprets <b>RS</b> as a regular expression,
    multi-line records are easy. Setting <b>RS</b> = &quot;\n\n+&quot;, makes
    one or more blank lines separate records. If <b>FS</b> = &quot; &quot; (the
    default), then single newlines, by the rules for &lt;SPACE&gt; above, become
    space and single newlines are field separators.</p>
<div class="Bd-indent">
<p class="Pp">For example, if</p>
<ul class="Bl-bullet">
  <li>a file is &quot;a&#x00A0;b\nc\n\n&quot;,</li>
  <li><b>RS</b> = &quot;\n\n+&quot; and</li>
  <li><b>FS</b> = &quot;&#x00A0;&quot;,</li>
</ul>
<p class="Pp">then there is one record &#x201C;a&#x00A0;b\nc&#x201D; with three
    fields &#x201C;a&#x201D;, &#x201C;b&#x201D; and &#x201C;c&#x201D;:</p>
<ul class="Bl-bullet">
  <li>using <b>FS</b> = &#x201C;\n&#x201D;, gives two fields &#x201C;a b&#x201D;
      and &#x201C;c&#x201D;;</li>
  <li>using <b>FS</b> = &#x201C;&#x201D;, gives one field identical to the
      record.</li>
</ul>
</div>
<p class="Pp">If you want lines with spaces or tabs to be considered blank, set
    <b>RS</b> = &#x201C;\n([&#x00A0;\t]*\n)+&#x201D;. For compatibility with
    other awks, setting <b>RS</b> = &quot;&quot; has the same effect as if blank
    lines are stripped from the front and back of files and then records are
    determined as if <b>RS</b> = &#x201C;\n\n+&#x201D;. POSIX requires that
    &#x201C;\n&#x201D; always separates records when <b>RS</b> = &quot;&quot;
    regardless of the value of <b>FS</b>. <b>mawk</b> does not support this
    convention, because defining &#x201C;\n&#x201D; as &lt;SPACE&gt; makes it
    unnecessary.</p>
<p class="Pp">Most of the time when you change <b>RS</b> for multi-line records,
    you will also want to change <b>ORS</b> to &#x201C;\n\n&#x201D; so the
    record spacing is preserved on output.</p>
</section>
<section class="Ss">
<h2 class="Ss"><b>13. Program execution</b></h2>
<p class="Pp">This section describes the order of program execution. First
    <b>ARGC</b> is set to the total number of command line arguments passed to
    the execution phase of the program.</p>
<ul class="Bl-bullet">
  <li><b>ARGV[0]</b> is set to the name of the AWK interpreter and</li>
  <li><b>ARGV[1]</b> ... <b>ARGV[ARGC-1]</b> holds the remaining command line
      arguments exclusive of options and program source.</li>
</ul>
<p class="Pp">For example, with</p>
<pre>
	mawk  -f  prog  v=1  A  t=hello  B

</pre>
<b>ARGC</b> = 5 with
<div class="Bd-indent"><b>ARGV[0]</b> = &quot;mawk&quot;,
<br/>
<b>ARGV[1]</b> = &quot;v=1&quot;,
<br/>
<b>ARGV[2]</b> = &quot;A&quot;,
<br/>
<b>ARGV[3]</b> = &quot;t=hello&quot; and
<br/>
<b>ARGV[4]</b> = &quot;B&quot;.</div>
<p class="Pp">Next, each <b>BEGIN</b> block is executed in order. If the program
    consists entirely of <b>BEGIN</b> blocks, then execution terminates, else an
    input stream is opened and execution continues. If <b>ARGC</b> equals 1, the
    input stream is set to stdin, else the command line arguments <b>ARGV[1]</b>
    ... <b>ARGV[ARGC-1]</b> are examined for a file argument.</p>
<p class="Pp">The command line arguments divide into three sets: file arguments,
    assignment arguments and empty strings &quot;&quot;. An assignment has the
    form <i>var</i>=<i>string</i>. When an <b>ARGV[i]</b> is examined as a
    possible file argument, if it is empty it is skipped; if it is an assignment
    argument, the assignment to <i>var</i> takes place and <b>i</b> skips to the
    next argument; else <b>ARGV[i]</b> is opened for input. If it fails to open,
    execution terminates with exit code 2. If no command line argument is a file
    argument, then input comes from stdin. Getline in a <b>BEGIN</b> action
    opens input. &#x201C;-&#x201D; as a file argument denotes stdin.</p>
<p class="Pp">Once an input stream is open, each input record is tested against
    each <i>pattern</i>, and if it matches, the associated <i>action</i> is
    executed. An expression pattern matches if it is boolean true (see the end
    of section 2). A <b>BEGIN</b> pattern matches before any input has been
    read, and an <b>END</b> pattern matches after all input has been read. A
    range pattern, <i>expr</i>1,<i>expr</i>2 , matches every record between the
    match of <i>expr</i>1 and the match <i>expr</i>2 inclusively.</p>
<p class="Pp">When end of file occurs on the input stream, the remaining command
    line arguments are examined for a file argument, and if there is one it is
    opened, else the <b>END</b> <i>pattern</i> is considered matched and all
    <b>END</b> <i>actions</i> are executed.</p>
<p class="Pp">In the example, the assignment v=1 takes place after the
    <b>BEGIN</b> <i>actions</i> are executed, and the data placed in v is typed
    number and string. Input is then read from file A. On end of file A, t is
    set to the string &quot;hello&quot;, and B is opened for input. On end of
    file B, the <b>END</b> <i>actions</i> are executed.</p>
<p class="Pp">Program flow at the <i>pattern</i> <i>{action}</i> level can be
    changed with the</p>
<pre>
	<b>next</b>
<b>	</b><b>nextfile</b>
<b>	</b><b>exit  </b><i>opt_expr</i>

</pre>
statements:
<ul class="Bl-bullet">
  <li>A <b>next</b> statement causes the next input record to be read and
      pattern testing to restart with the first <i>pattern {action}</i> pair in
      the program.</li>
  <li>A <b>nextfile</b> statement tells <b>mawk</b> to stop processing the
      current input file. It then updates FILENAME to the next file listed on
      the command line, and resets FNR to 1.</li>
  <li>An <b>exit</b> statement causes immediate execution of the <b>END</b>
      actions or program termination if there are none or if the <b>exit</b>
      occurs in an <b>END</b> action. The <i>opt_expr</i> sets the exit value of
      the program unless overridden by a later <b>exit</b> or subsequent
    error.</li>
</ul>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="ENVIRONMENT"><a class="permalink" href="#ENVIRONMENT">ENVIRONMENT</a></h1>
<p class="Pp"><b>Mawk</b> recognizes these variables:</p>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="MAWKBINMODE"><a class="permalink" href="#MAWKBINMODE">MAWKBINMODE</a></dt>
  <dd>(see <b>COMPATIBILITY</b>)</dd>
  <dt id="MAWK_LONG_OPTIONS"><a class="permalink" href="#MAWK_LONG_OPTIONS">MAWK_LONG_OPTIONS</a></dt>
  <dd>If this is set, <b>mawk</b> uses its value to decide what to do with
      GNU-style long options:</dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="allow"><a class="permalink" href="#allow">allow</a></dt>
  <dd><b>Mawk</b> allows the option to be checked against the (small) set of
      long options it recognizes.</dd>
</dl>
<dl class="Bl-tag">
  <dt></dt>
  <dd>The long names from the <b>-W</b> option are recognized, e.g.,
      <b>--version</b> is derived from <b>-Wversion</b>.</dd>
</dl>
<dl class="Bl-tag">
  <dt id="error"><a class="permalink" href="#error">error</a></dt>
  <dd><b>Mawk</b> prints an error message and exits. This is the default.</dd>
  <dt id="ignore"><a class="permalink" href="#ignore">ignore</a></dt>
  <dd><b>Mawk</b> ignores the option, unless it happens to be one of the one it
      recognizes.</dd>
  <dt id="warn"><a class="permalink" href="#warn">warn</a></dt>
  <dd>Print an warning message and otherwise ignore the option.</dd>
</dl>
</div>
<dl class="Bl-tag">
  <dt></dt>
  <dd>If the variable is unset, <b>mawk</b> prints an error message and
    exits.</dd>
</dl>
<dl class="Bl-tag">
  <dt id="WHINY_USERS"><a class="permalink" href="#WHINY_USERS">WHINY_USERS</a></dt>
  <dd>This is a <b>gawk</b> 3.1.0 feature, removed in the 4.0.0 release. It
      tells <b>mawk</b> to sort array indices before it starts to iterate over
      the elements of an array.</dd>
</dl>
</div>
</section>
<section class="Sh">
<h1 class="Sh" id="COMPATIBILITY"><a class="permalink" href="#COMPATIBILITY">COMPATIBILITY</a></h1>
<section class="Ss">
<h2 class="Ss" id="MAWK_1.3.3_versus_POSIX_1003.2_Draft_11.3"><a class="permalink" href="#MAWK_1.3.3_versus_POSIX_1003.2_Draft_11.3">MAWK
  1.3.3 versus POSIX 1003.2 Draft 11.3</a></h2>
<p class="Pp">The POSIX 1003.2(draft 11.3) definition of the AWK language is AWK
    as described in the AWK book with a few extensions that appeared in
    SystemVR4 nawk. The extensions are:</p>
<div class="Bd-indent">
<ul class="Bl-bullet">
  <li>New functions: toupper() and tolower().</li>
  <li>New variables: ENVIRON[] and CONVFMT.</li>
  <li>ANSI C conversion specifications for printf() and sprintf().</li>
  <li>New command options: -v var=value, multiple -f options and implementation
      options as arguments to -W.</li>
  <li>For systems (MS-DOS or Windows) which provide a <i>setmode</i> function,
      an environment variable MAWKBINMODE and a built-in variable BINMODE. The
      bits of the BINMODE value tell <b>mawk</b> how to modify the <b>RS</b> and
      <b>ORS</b> variables:</li>
</ul>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt>0</dt>
  <dd>set standard input to binary mode, and if BIT-2 is unset, set <b>RS</b> to
      &quot;\r\n&quot; (CR/LF) rather than &quot;\n&quot; (LF).</dd>
  <dt>1</dt>
  <dd>set standard output to binary mode, and if BIT-2 is unset, set <b>ORS</b>
      to &quot;\r\n&quot; (CR/LF) rather than &quot;\n&quot; (LF).</dd>
  <dt>2</dt>
  <dd>suppress the assignment to <b>RS</b> and <b>ORS</b> of CR/LF, making it
      possible to run scripts and generate output compatible with Unix
      line-endings.</dd>
</dl>
</div>
</div>
<p class="Pp">POSIX AWK is oriented to operate on files a line at a time.
    <b>RS</b> can be changed from &quot;\n&quot; to another single character,
    but it is hard to find any use for this &#x2014; there are no examples in
    the AWK book. By convention, <b>RS</b> = &quot;&quot;, makes one or more
    blank lines separate records, allowing multi-line records. When <b>RS</b> =
    &quot;&quot;, &quot;\n&quot; is always a field separator regardless of the
    value in <b>FS</b>.</p>
<p class="Pp"><b>mawk</b>, on the other hand, allows <b>RS</b> to be a regular
    expression. When &quot;\n&quot; appears in records, it is treated as space,
    and <b>FS</b> always determines fields.</p>
<p class="Pp">Removing the line at a time paradigm can make some programs
    simpler and can often improve performance. For example, redoing example 3
    from above,</p>
<pre>
	BEGIN { RS = &quot;[^A-Za-z]+&quot; }
	{ word[ $0 ] = &quot;&quot; }
	END { delete  word[ &quot;&quot; ]
	  for( i in word )  cnt++
	  print cnt
	}

</pre>
counts the number of unique words by making each word a record. On moderate size
  files, <b>mawk</b> executes twice as fast, because of the simplified inner
  loop.
<p class="Pp">The following program replaces each comment by a single space in a
    C program file,</p>
<pre>
	BEGIN {
	  RS = &quot;/\*([^*]|\*+[^/*])*\*+/&quot;
		# comment is record separator
	  ORS = &quot; &quot;
	  getline  hold
<br/>
       }
<br/>
       { print hold ; hold = $0 }
<br/>
       END { printf &quot;%s&quot; , hold }

</pre>
Buffering one record is needed to avoid terminating the last record with a
  space.
<p class="Pp">With <b>mawk</b>, the following are all equivalent,</p>
<pre>
	x ~ /a\+b/    x ~ &quot;a\+b&quot;     x ~ &quot;a\\+b&quot;

</pre>
The strings get scanned twice, once as string and once as regular expression. On
  the string scan, <b>mawk</b> ignores the escape on non-escape characters while
  the AWK book advocates <i>\c</i> be recognized as <i>c</i> which necessitates
  the double escaping of meta-characters in strings. POSIX explicitly declines
  to define the behavior which passively forces programs that must run under a
  variety of awks to use the more portable but less readable, double escape.
<p class="Pp">POSIX AWK does not recognize &quot;/dev/std{in,out,err}&quot;.
    Some systems provide an actual device for this, allowing AWKs which do not
    implement the feature directly to support it.</p>
<p class="Pp">POSIX AWK does not recognize \x hex escape sequences in strings.
    Unlike ANSI C, <b>mawk</b> limits the number of digits that follows \x to
    two as the current implementation only supports 8 bit characters.</p>
<p class="Pp">POSIX explicitly leaves the behavior of <b>FS</b> = &quot;&quot;
    undefined, and mentions splitting the record into characters as a possible
    interpretation, but currently this use is not portable across
    implementations.</p>
<p class="Pp">Some features were not part of the POSIX standard until long after
    their introduction in <b>mawk</b> and other implementations. These have been
    approved, though still (as of July 2020), are not part of a published
    standard:</p>
<ul class="Bl-bullet">
  <li>The built-in <b>fflush</b> first appeared in a 1993 AT&amp;T awk released
      to netlib. It was approved for the POSIX standard in 2012.</li>
  <li>Aggregate deletion with <b>delete</b> <i>array</i> was approved in
    2018.</li>
</ul>
</section>
<section class="Ss">
<h2 class="Ss" id="Random_numbers"><a class="permalink" href="#Random_numbers">Random
  numbers</a></h2>
<p class="Pp">POSIX does not prescribe a method for initializing random numbers
    at startup.</p>
<p class="Pp">In practice, most implementations do nothing special, which makes
    <b>srand</b> and <b>rand</b> follow the C runtime library, making the
    initial seed value 1. Some implementations (Solaris XPG4 and Tru64) return 0
    from the first call to <b>srand</b>, although the results from <b>rand</b>
    behave as if the initial seed is 1. Other implementations return 1.</p>
<p class="Pp">While <b>mawk</b> can call <b>srand</b> at startup with no
    parameter (initializing random numbers from the clock), this feature may be
    suppressed using conditional compilation.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Extensions_added_for_compatibility_for_GAWK_and_BWK"><a class="permalink" href="#Extensions_added_for_compatibility_for_GAWK_and_BWK">Extensions
  added for compatibility for GAWK and BWK</a></h2>
<p class="Pp"><b>Nextfile</b> is a <b>gawk</b> extension (also implemented by
    BWK awk). It was approved for the POSIX standard in September 2012, and is
    expected to be part of the next revision of the standard.</p>
<p class="Pp"><b>Mktime</b>, <b>strftime</b>&#x00A0;and <b>systime</b> are
    <b>gawk</b> extensions.</p>
<p class="Pp">The &quot;/dev/stdin&quot; feature was added to <b>mawk</b> after
    1.3.4, for compatibility with <b>gawk</b> and BWK awk. The corresponding
    &quot;-&quot; (alias for /dev/stdin) was present in <b>mawk</b> 1.3.3.</p>
<p class="Pp">Interval expressions, e.g., a range <i>{m,n}</i> in Extended
    Regular Expressions (EREs), were not supported in awk (or even the original
    &#x201C;nawk&#x201D;):</p>
<ul class="Bl-bullet">
  <li>Gawk provided this feature in 1991 (and later, in 1998, options for
      turning it off, for compatibility with &#x201C;traditional
    awk&#x201D;).</li>
  <li>Interval expressions, were introduced into <i>awk</i> regular expressions
      in IEEE 1003.1-2001 (also known as Unix 03), along with some
      internationalization features.</li>
  <li>Apple modified its copy of the original awk in April 2006, making this
      version of awk support interval expressions.</li>
</ul>
<dl class="Bl-tag">
  <dt></dt>
  <dd>The updated source provides for compatibility with older
      &#x201C;legacy&#x201D; versions using an environment variable, making this
      &#x201C;Unix 2003&#x201D; feature (perhaps meant as Unix 03) the
    default.</dd>
</dl>
<ul class="Bl-bullet">
  <li>NetBSD developers copied this change in January 2018, omitting the
      compatibility option, and then applied it to BWK awk.</li>
  <li>The interval expression implementation in <b>mawk</b> is based on changes
      proposed by James Parkinson in April 2016.</li>
</ul>
<p class="Pp"><b>Mawk</b> also recognizes a few gawk-specific command line
    options for script compatibility:</p>
<div class="Bd-indent">
<p class="Pp"><b>--help</b>, <b>--posix</b>, <b>-r</b>, <b>--re-interval</b>,
    <b>--traditional</b>, <b>--version</b></p>
</div>
</section>
<section class="Ss">
<h2 class="Ss" id="Subtle_Differences_not_in_POSIX_or_the_AWK_Book"><a class="permalink" href="#Subtle_Differences_not_in_POSIX_or_the_AWK_Book">Subtle
  Differences not in POSIX or the AWK Book</a></h2>
<p class="Pp">Finally, here is how <b>mawk</b> handles exceptional cases not
    discussed in the AWK book or the POSIX draft. It is unsafe to assume
    consistency across awks and safe to skip to the next section.</p>
<p class="Pp"></p>
<div class="Bd-indent">
<ul class="Bl-bullet">
  <li>substr(s, i, n) returns the characters of s in the intersection of the
      closed interval [1, length(s)] and the half-open interval [i, i+n). When
      this intersection is empty, the empty string is returned; so
      substr(&quot;ABC&quot;, 1, 0) = &quot;&quot; and substr(&quot;ABC&quot;,
      -4, 6) = &quot;A&quot;.</li>
  <li>Every string, including the empty string, matches the empty string at the
      front so, s ~ // and s ~ &quot;&quot;, are always 1 as is match(s, //) and
      match(s, &quot;&quot;). The last two set <b>RLENGTH</b> to 0.</li>
  <li>index(s, t) is always the same as match(s, t1) where t1 is the same as t
      with metacharacters escaped. Hence consistency with match requires that
      index(s, &quot;&quot;) always returns 1. Also the condition, index(s,t) !=
      0 if and only t is a substring of s, requires
      index(&quot;&quot;,&quot;&quot;) = 1.</li>
  <li>If getline encounters end of file, getline var, leaves var unchanged.
      Similarly, on entry to the <b>END</b> actions, <b>$0</b>, the fields and
      <b>NF</b> have their value unaltered from the last record.</li>
</ul>
</div>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="BUGS"><a class="permalink" href="#BUGS">BUGS</a></h1>
<p class="Pp"><b>mawk</b> implements <b>printf()</b> and <b>sprintf()</b> using
    the C library functions, printf and sprintf, so full ANSI compatibility
    requires an ANSI C library. In practice this means the h conversion
    qualifier may not be available.</p>
<p class="Pp">Also <b>mawk</b> inherits any bugs or limitations of the library
    functions.</p>
<p class="Pp">Implementors of the AWK language have shown a consistent lack of
    imagination when naming their programs.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="EXAMPLES"><a class="permalink" href="#EXAMPLES">EXAMPLES</a></h1>
<pre>1. emulate cat.
	{ print }
2. emulate wc.
	{ chars += length($0) + 1  # add one for the \n
	  words += NF
	}
	END{ print NR, words, chars }
3. count the number of unique &#x201C;real words&#x201D;.
	BEGIN { FS = &quot;[^A-Za-z]+&quot; }
	{ for(i = 1 ; i &lt;= NF ; i++)  word[$i] = &quot;&quot; }
	END { delete word[&quot;&quot;]
	      for ( i in word )  cnt++
	      print cnt
	}
</pre>
<p class="Pp">4. sum the second field of every record based on the first
  field.</p>
<pre>
	$1 ~ /credit|gain/ { sum += $2 }
	$1 ~ /debit|loss/  { sum -= $2 }
	END { print sum }
5. sort a file, comparing as string
	{ line[NR] = $0 &quot;&quot; }  # make sure of comparison type
			      # in case some lines look numeric
	END {  isort(line, NR)
	  for(i = 1 ; i &lt;= NR ; i++) print line[i]
	}
	#insertion sort of A[1..n]
	function isort( A, n,	i, j, hold)
	{
	  for( i = 2 ; i &lt;= n ; i++)
	  {
	    hold = A[j = i]
	    while ( A[j-1] &gt; hold )
	    { j-- ; A[j+1] = A[j] }
	    A[j] = hold
	  }
	  # sentinel A[0] = &quot;&quot; will be created if needed
	}
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="AUTHORS"><a class="permalink" href="#AUTHORS">AUTHORS</a></h1>
<p class="Pp">Mike Brennan (brennan@whidbey.com).
  <br/>
  Thomas E. Dickey &lt;dickey@invisible-island.net&gt;.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SEE_ALSO"><a class="permalink" href="#SEE_ALSO">SEE
  ALSO</a></h1>
<p class="Pp"><b>grep</b>(1)</p>
<p class="Pp">Aho, Kernighan and Weinberger, <i>The AWK Programming
    Language</i>, Addison-Wesley Publishing, 1988, (the AWK book), defines the
    language, opening with a tutorial and advancing to many interesting programs
    that delve into issues of software design and analysis relevant to
    programming in any language.</p>
<p class="Pp"><i>The GAWK Manual</i>, The Free Software Foundation, 1991, is a
    tutorial and language reference that does not attempt the depth of the AWK
    book and assumes the reader may be a novice programmer. The section on AWK
    arrays is excellent. It also discusses POSIX requirements for AWK.</p>
<p class="Pp"><b>mawk-arrays</b>(7) discusses <b>mawk</b>'s implementation of
    arrays.</p>
<p class="Pp"><b>mawk-code</b>(7) gives more information on the
    <b>-W&#x00A0;dump</b> option.</p>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2024-01-23</td>
    <td class="foot-os">Version 1.3.4</td>
  </tr>
</table>
</main>
</body>
</html>
